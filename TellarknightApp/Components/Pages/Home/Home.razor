@page "/"
@using TellarknightApp.Services
@using TellarknightApp.Models
@using CommunityToolkit.Maui
@using System.Text
@using CommunityToolkit.Maui.Storage
@using CommunityToolkit.Maui.Alerts
@using TellarknightApp.Components.Pages.Home.HomeComponents;
@inject SupportedCards supportedCards
@inject Decklist decklist
@inject SupportedCards supportedCards
@inject Decklist decklist
@inject IFileSaver FileSaver

<div class="app-grid-container">
    <div class="item grid-statistics">
        <StatisticsComponent DeckStatistics="@deckStatistics" DeckStatisticsHand="@deckStatisticsHand" StatValues="@statValues" HandTest="@handTest" CheckDeck="CheckDeck" CheckHand="CheckHand" ResetCards="ResetCards"></StatisticsComponent>
    </div>
    <div class="item grid-cards">
        <CardsComponent SearchValues="@searchValues" CardSearch="CardSearch"></CardsComponent>
    </div>
</div>

@code{
    public StatisticsComponentValues statValues = new StatisticsComponentValues();
    public SearchComponentValues searchValues { get; set; } = new SearchComponentValues();
    private DeckStatistics deckStatistics = new DeckStatistics();
    private DeckStatistics deckStatisticsHand = new DeckStatistics();
    private GameState gameState = new GameState();
    private GameState gameStateHand = new GameState();
    private List<Card> handTest = new List<Card>()
    {
        new EmptyCard(){ Image = "./CardArt/CardBack.jpg" }, 
        new EmptyCard(){ Image = "./CardArt/CardBack.jpg" },
        new EmptyCard(){ Image = "./CardArt/CardBack.jpg" },
        new EmptyCard(){ Image = "./CardArt/CardBack.jpg" },
        new EmptyCard(){ Image = "./CardArt/CardBack.jpg" }
    };




    [Parameter]
    public EventCallback UpdateState { get; set; }
    private string searchQuery = string.Empty;
    private string typeQuery = string.Empty;
    private string archetypeQuery = string.Empty;
    private bool select = true;
    private List<string> optionsType = new List<string>
    {
        "Monster",
        "Spell",
        "Trap",
    };

    private int currentPage = 1;
    private const int itemsPerPage = 30;
    private int totalItems;
    private string GenerateCardTooltip(Card card)
    {
        var tooltipLines = new List<string>
    {
        $"Name: {card.Name}",
        $"Type: {card.Type}"
    };
        if (!string.IsNullOrWhiteSpace(card.Attribute))
        {
            tooltipLines.Add($"Attribute: {card.Attribute}");
        }
        if (card.Level.HasValue && card.Role != "Extra Deck")
        {
            tooltipLines.Add($"Level: {card.Level.Value}");
        }
        if (card.Level.HasValue && card.Role == "Extra Deck")
        {
            tooltipLines.Add($"Level/Rank: {card.Level.Value}");
        }
        if (card.Attack.HasValue || card.Defense.HasValue)
        {
            tooltipLines.Add($"ATK/DEF: {(card.Attack?.ToString() ?? "N/A")}/{(card.Defense?.ToString() ?? "N/A")}");
        }
        if (card.Scale.HasValue)
        {
            tooltipLines.Add($"Scale: {card.Scale.Value}");
        }

        tooltipLines.Add($"Archetype: {(card.Archetype != null ? string.Join(", ", card.Archetype) : "N/A")}");

        return string.Join("\n", tooltipLines);
    }






    // --------------------------
    // Statistics Code
    // --------------------------

    private async Task CheckDeck()
    {
        statValues.MaximumCount = (statValues.MaximumCount > 100000) ? 100000 : (statValues.MaximumCount < 5000 ? 5000 : statValues.MaximumCount);
        statValues.StartingHand = (statValues.StartingHand < 1) ? 1 : (statValues.StartingHand > 6 ? 6 : statValues.StartingHand);

        statValues.Idle = false;
        statValues.Active = true;
        statValues.CurrentCount = 0;
        deckStatistics = new DeckStatistics();

        int tempCount = 0;
        int tempCountNext = (int)(statValues.MaximumCount * 0.001);
        Random random = new Random();

        decklist.BuildDecklist(supportedCards);
        await InvokeAsync(StateHasChanged);

        // Testing

        // Main Loop
        for (int i = 0; i < statValues.MaximumCount; i++)
        {
            gameState = RefreshGameState(gameState);
            gameState = ShuffleDeck(gameState);
            gameState = DrawHand(gameState);

            // Check Hand & Deck For Optimal Searches
            gameState = CardSearcher.CardSearch(gameState);

            // Analyze Hand & Update Hand Statistics
            deckStatistics = HandAnalyzer.HandCheck(gameState, deckStatistics);

            // Visual updates
            statValues.CurrentCount++;
            tempCount++;
            if (tempCount >= tempCountNext)
            {
                tempCountNext = tempCountNext + random.Next((int)(statValues.MaximumCount * 0.0005), (int)(statValues.MaximumCount * 0.015));
                await InvokeAsync(StateHasChanged);
            }
        }
        statValues.Active = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task CheckHand()
    {
        statValues.StartingHand = (statValues.StartingHand < 1) ? 1 : (statValues.StartingHand > 6 ? 6 : statValues.StartingHand);

        deckStatisticsHand = new DeckStatistics();
        gameStateHand = new GameState();
        handTest = new List<Card>();

        decklist.BuildDecklist(supportedCards);
        gameStateHand = RefreshGameState(gameStateHand);
        gameStateHand = ShuffleDeck(gameStateHand);
        gameStateHand = DrawHand(gameStateHand);

        foreach(Card card in gameStateHand.Hand)
        {
            handTest.Add(card);
        }

        gameStateHand = CardSearcher.CardSearch(gameStateHand);
        deckStatisticsHand = HandAnalyzer.HandCheck(gameStateHand, deckStatisticsHand);

        statValues.HandTested = true;
        await InvokeAsync(StateHasChanged);
    }

    // Clears the gamestate and transfer decklist contents to gamestate
    private GameState RefreshGameState(GameState gameStateInput)
    {
        gameStateInput = new GameState();
        foreach (Card card in decklist.MainDeck)
        {
            gameStateInput.Deck.Add(card.Clone());
        }
        foreach (Card card in decklist.ExtraDeck)
        {
            gameStateInput.ExtraDeck.Add(card.Clone());
        }
        return gameStateInput;

    }

    // Shuffles the deck fisher-yates style
    private GameState ShuffleDeck(GameState gameStateInput)
    {
        var random = new Random();
        int deckCount = gameStateInput.Deck.Count;
        for (int i = 0; i < 3; i++)
        {
            while (deckCount > 1)
            {
                deckCount--;
                int randomIndex = random.Next(deckCount + 1);
                var tempCard = gameStateInput.Deck[randomIndex];
                gameStateInput.Deck[randomIndex] = gameStateInput.Deck[deckCount];
                gameStateInput.Deck[deckCount] = tempCard;
            }
        }
        return gameStateInput;

    }

    public GameState DrawHand(GameState gameStateInput)
    {
        for (int i = 0; i < statValues.StartingHand; i++)
        {
            gameStateInput.Hand.Add(gameStateInput.Deck[0]);
            gameStateInput.Deck.RemoveAt(0);
        }
        return gameStateInput;
    }

    public void ResetCards()
    {
        statValues.CurrentCount = 0;
        deckStatistics = new DeckStatistics();
        deckStatisticsHand = new DeckStatistics();
        gameState = new GameState();
        gameStateHand = new GameState();
        decklist = new Decklist();
        statValues.HandTested = false;

        handTest = new List<Card>()
        {
            new EmptyCard(){ Image = "./CardArt/CardBack.jpg" },
            new EmptyCard(){ Image = "./CardArt/CardBack.jpg" },
            new EmptyCard(){ Image = "./CardArt/CardBack.jpg" },
            new EmptyCard(){ Image = "./CardArt/CardBack.jpg" },
            new EmptyCard(){ Image = "./CardArt/CardBack.jpg" }
        };

        supportedCards.RefreshUpdate();
        statValues.Idle = true;
    }

    protected override async Task OnInitializedAsync()
    {
        supportedCards.Action += StateHasChanged;
        decklist.Action += StateHasChanged;
    }

















    // --------------------------
    // Card Search Code
    // --------------------------

    public void DecklistButton()
    {
        searchValues.Select = !searchValues.Select;
        decklist.BuildDecklist(supportedCards);
    }

    public async void CardSearch()
    {
        searchValues.TotalItems = supportedCards.Cards
            .Where(x => string.IsNullOrWhiteSpace(searchValues.SearchQuery) ? true : x.Name.Contains(searchValues.SearchQuery))
            .Where(x => string.IsNullOrWhiteSpace(searchValues.ArchetypeQuery) ? true : x.Archetype.Contains(searchValues.ArchetypeQuery))
            .Where(x => string.IsNullOrWhiteSpace(searchValues.TypeQuery) ? true : (searchValues.TypeQuery == "Monster" ? (x.Type != "Spell" && x.Type != "Trap") : x.Type == searchValues.TypeQuery))
            .Count();

        searchValues.CurrentPage = 1;
        await OnInitializedAsync();
    }

    public void IncreaseQuantity(Card card)
    {
        card.Quantity++;
    }

    public void DecreaseQuantity(Card card)
    {
        card.Quantity--;
    }

    private void NextPage()
    {
        if (searchValues.CurrentPage * searchValues.ItemsPerPage < searchValues.TotalItems)
            searchValues.CurrentPage++;
    }

    private void PreviousPage()
    {
        if (searchValues.CurrentPage > 1)
            searchValues.CurrentPage--;
    }

    private string GenerateYdk()
    {
        decklist.BuildDecklist(supportedCards);
        var sb = new StringBuilder();

        sb.AppendLine("#main");
        foreach (var card in decklist.MainDeck.Where(x => x.Role != "Extra Deck" && x.Id != 0))
        {
            sb.AppendLine(card.Id.ToString());
        }

        sb.AppendLine("#extra");
        foreach (var card in decklist.ExtraDeck.Where(x => x.Id != 0))
        {
            sb.AppendLine(card.Id.ToString());
        }

        sb.AppendLine("!side");

        return sb.ToString();
    }

    async Task SaveFile()
    {
        using var filecontent = new MemoryStream(Encoding.UTF8.GetBytes(GenerateYdk()));
        var fileSaverResult = await FileSaver.SaveAsync("tellarknight.ydk", filecontent);

        if (fileSaverResult.IsSuccessful)
        {
            await Toast.Make($"The file was saved successfully to location: {fileSaverResult.FilePath}").Show();
        }
        else
        {
            await Toast.Make($"The file was not saved successfully with error: {fileSaverResult.Exception.Message}").Show();
        }
    }
}
