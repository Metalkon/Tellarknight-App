@page "/"
@using TellarknightApp.Models;
@using Services;

<div class="page-background-class">
    <h2 style="text-align: center; margin-bottom: 2%; color: white;">Tellarknight Deck Statistics App</h2>

    <div id="content" style="display: flex; flex-direction: column; align-items: center; margin: 20px;">
        <div id="top" style="display: flex; width: 100%;">
            <div id="left" style="width: 50%; margin-right: 15px; margin-left: 15px;">
                <div style="text-align: center;">
                    <h5 style="color: white; margin-bottom: 1.5%;"><b>Deck Statistics</b></h5>
                </div>

                <div class="row">
                    <!-- Left content continued... -->
                    <div class="box">
                        <b>Basic Stats:</b> <br />
                        Deck Size: @(deck.Count + hand.Count + onField.Count + gy.Count + scales.Count) <br />
                        Total Monsters (Deck): @(hand.Count(x => x.Level != null) + deck.Count(x => x.Level != null)) <br />
                        Combo Chance: @(((totalCount - stats.BrickChance) / totalCount) * 100)% <br />
                        Brick Chance: @((stats.BrickChance / totalCount) * 100)%  <br />
                        (1 In @(totalCount / stats.BrickChance)) <br />
                        <br />
                        <br />
                        <br />
                    </div>
                    <div class="box">
                        <b>Zefra Stats:</b> <br />
                        Pendulumn Chance (Any): @((stats.PendulumnSummon / totalCount) * 100)% <br />
                        Pendulumn (Zefraath/Thuban): @((stats.ZefraathAndThuban / totalCount) * 100)% <br />
                        Pendulumn (Zefraath/SHS): @((stats.ZefraathAndSHS / totalCount) * 100)% <br />
                        <br />
                        Pendulumn (NS Available): N/A <br />
                        Pendulumn (NS/Zefraath/SHS): N/A <br />
                        Obtain Trap (Any Xyz): @((stats.ZefraComboWithTrap / totalCount) * 100)%<br />

                    </div>
                </div>
                <div class="row">
                    <div class="box">
                        <b>Xyz Stats:</b> <br />
                        Xyz Summon (0 Tellars): @((stats.AverageXyzNoTellar / totalCount) * 100)% <br />
                        Xyz Summon (1 Tellars): @(((stats.AverageXyzWithTellar - stats.AverageXyzTwoTellars) / totalCount) * 100)% <br />
                        Xyz Summon (2 Tellars): @((stats.AverageXyzTwoTellars / totalCount) * 100)% <br />
                        Xyz Summon (Unknown): @((stats.AverageXyzUnknown / totalCount) * 100)% <br />
                        <br />
                        Xyz Summon (Lyran/Unuk) @((stats.AverageXyzUnukOrLyran / totalCount) * 100)% <br />
                        (Altairan or Continuous Spell Prepared)
                        <br />
                        <br />

                    </div>
                    <div class="box">
                        <b>Other Stats:</b> <br />
                        Average # Tellars: @(stats.AverageTellars / totalCount) <br />
                        Average # Hand Traps: @(stats.AverageHandTraps / totalCount) <br />
                        Isolde Brick Chance: @((stats.IsoldeBrick / totalCount) * 100)% <br />

                        <br />
                        Turn Skip FTK (2 Cards): N/A <br />
                        Turn Skip FTK (3 Cards): N/A <br />
                        Turn Skip FTK (4 Cards): N/A <br />
                    </div>
                </div>
            </div>
            <div id="right" style="width: 50%; padding: 1px;">
                <div class="container" style="width: 95%; max-width: 100%; overflow: hidden; border-radius: 5%; background-color: #f8f8f8; padding: 15px;">
                    <table class="table table-bordered table-striped custom-table" style="width: 100%; padding: 20px;">
                        <tbody>
                            <!-- Right content continued... -->
                            @foreach (var chunk in supportedCards.Cards.Select((value, index) => new { Index = index, Value = value }).GroupBy(x => x.Index / 9))
                            {
                                <tr>
                                    @foreach (var card in chunk.Select(x => x.Value))
                                    {
                                        <td style="max-width: 20%; width: auto; text-align: center; border: 1px solid #f8f8f8; background-color: #f8f8f8; padding: 2px; border-radius: 2px;">
                                            <img src="@card.Image" alt="@card.Name" style="display: block; margin: 0 auto; width: 100%;">
                                            <input type="text" style="width: 100%; text-align: center;" @bind-value="card.Quantity">
                                        </td>
                                    }
                                </tr>
                            }
                        </tbody>
                    </table>
                    <div style="text-align: center;">
                        <b>Hand Size:</b>
                        <input type="text" style="width: 12%; text-align: center;" @bind-value="startingHand">
                        <button class="btn btn-primary" @onclick="@(() => { if (!active) CheckDeck(); })">Check Deck</button>
                        <div style="margin-top: 2px;">Hands Tested: @totalCount</div>
                    </div>
                </div>
            </div>

        </div>
        <div id="bottom" style="clear: both; text-align: center; color: white;">
            Bottom Options Here
        </div>
    </div>
</div>

<style>
    .row {
        display: flex;
        gap: 20px;
    }

    .box {
        flex: 1;
        min-height: 150px;
        padding: 20px;
        background-color: #f8f8f8;
        color: #333;
        border-radius: 5%;
        box-sizing: border-box; /* Ensure box-sizing is set to border-box */
        margin-bottom: 20px;
    }

    #left {
        width: 50%;
        margin-right: 5px;
        margin-left: 15px;
    }

    #right {
        width: 50%;
        padding: 1px;
    }

    .page-background-class {
        background-image: url(../background.png);
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        height: 100vh; /* Set the height to 100% of the viewport height */
    }

    .custom-table {
        border: 2px solid #f8f8f8;
        border-collapse: collapse;
    }

    .custom-table td {
        border: 1px solid #f8f8f8;
        background-color: #f8f8f8;
        padding: 10px;
    }
</style>

@code {
    private bool active = false;
    private int checkCount = 25000;
    private int totalCount;
    private int startingHand = 5;
    private bool normalSummon = false;
    private List<Card> onField = new List<Card>();
    private List<Card> scales = new List<Card>();
    private DeckStatistics stats = new DeckStatistics();
    private List<Card> deck = new List<Card>();
    private List<Card> hand = new List<Card>();
    private List<Card> gy = new List<Card>();
    private SupportedCards supportedCards = new SupportedCards();

    // Test
    List<Card> startingHandTest = new List<Card>();

    private async Task CheckDeck()
    {
        active = true;
        stats = new DeckStatistics();
        totalCount = 0;
        int tempCount = 0;
        int tempCountNext = (int)(checkCount * 0.001);
        Random random = new Random();

        for (int i = 0; i < checkCount; i++)
        {
            int deckSizePostSearch = hand.Count + deck.Count + gy.Count + onField.Count + scales.Count;

            // Reset Everything
            deck.Clear();
            hand.Clear();
            onField.Clear();
            scales.Clear();
            gy.Clear();
            bool normalSummon = false;

            // Build Deck & Hand
            BuildDeck();
            ShuffleDeck();
            DrawHand();

            // tests only
            startingHandTest = hand.ToList();

            // Check Hand & Deck For Optimal Searches
            (hand, deck, gy, normalSummon, onField, scales) = CardSearcher.CardSearch(hand, deck, gy, normalSummon, onField, scales);

            // Analyze Hand & Update Hand Statistics
            stats = HandAnalyzer.HandCheck(hand, deck, gy, normalSummon, onField, scales, stats);


            totalCount++;
            tempCount++;
            if (tempCount >= tempCountNext)
            {
                tempCountNext = tempCountNext + random.Next((int)(checkCount * 0.0005), (int)(checkCount * 0.015));
                await InvokeAsync(StateHasChanged);
            }
            active = false;
        }
        await InvokeAsync(StateHasChanged);
    }

    private void BuildDeck()
    {
        foreach (Card card in supportedCards.Cards)
        {
            if (card.Quantity > 3 && card.Name != "Hand Trap" && card.Name != "Level 4" && card.Name != "Empty Card")
            {
                card.Quantity = 3;
            }
            if (card.Quantity > 0)
            {
                for (int i = 0; i < card.Quantity; i++)
                {
                    deck.Add(card);
                }
            }
        }
        while(deck.Count < 40)
        {
            deck.Add(new Card() 
            { 
                Name = "Empty Card",
                Archetype = "None",
                Type = "None",
                Role = "None"
            });
        }
    }

    private void ShuffleDeck()
    {
        var random = new Random();
        for (int i = 0; i < 10; i++)
        {
            int deckCount = deck.Count;
            while (deckCount > 1)
            {
                deckCount--;
                int randomIndex = random.Next(deckCount + 1);
                var tempCard = deck[randomIndex];
                deck[randomIndex] = deck[deckCount];
                deck[deckCount] = tempCard;
            }
        }
    }

    public void DrawHand()
    {
        Random random = new Random();
        for (int i = 0; i < startingHand; i++)
        {
            hand.Add(deck[0]);
            deck.RemoveAt(0);
        }
    }
}
